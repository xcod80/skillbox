print('Задача 7. Яйца')

# В рамках программы колонизации Марса
# компания «Спейс Инжиниринг» вывела особую породу черепах,
# которые, по задумке, должны размножаться, откладывая яйца в марсианском грунте.
# Откладывать яйца слишком близко к поверхности опасно из-за радиации,
# а слишком глубоко — из-за давления грунта и недостатка кислорода.
# Вообще, факторов очень много,
# но специалисты проделали большую работу и предположили,
# что уровень опасности для черепашьих яиц рассчитывается по формуле
# D = x**3 − 3x**2 − 12x + 10,
# где x — глубина кладки в метрах,
# а D — уровень опасности в условных единицах.
# 
# Для тестирования гипотезы
# нужно взять пробу грунта на безопасной, согласно формуле, глубине.
# 
# Напишите программу,
# находящую такое значение глубины "х", при котором уровень опасности как можно более близок к нулю.
# На вход программе подаётся максимально допустимое отклонение уровня опасности от нуля,
# а программа должна рассчитать приблизительное значение "х",
# удовлетворяющее этому отклонению.
# 
# Известно, что глубина точно больше нуля и меньше четырёх метров.
# 
# Обеспечьте контроль ввода.
# 
# Пример:
# Введите максимально допустимый уровень опасности: 0.01
# 
# Приблизительная глубина безопасной кладки: 0.732421875 м
import math

def sgn(x): #функция signifer
  if x > 0:
    return 1
  elif x < 0:
    return -1
  else:
    return 0

def diapasone(x1, x2, x3, min, max):
  if min < x1 < max:
    return x1
  elif min < x2 < max:
    return x2
  elif min < x3 < max:
    return x3
  else:
    return 'Недопустимый коэффициент опасности!!!'

D = float(input('Введите максимально допустимый уровень опасности: '))
#y = x**3 − 3x**2 − 12x + (10 - D)
#Промежуточные вычисления(Теорема Виета)
Q = 5 #Q ** 3 = 125
R = (27 * (10 - D) - 378) / 54
S = 125 - R ** 2
x1 = x2 = x3 = 0

if S > 0:
  Fi = math.acos(R / math.sqrt(Q ** 3))/3
  x1 = -2 * math.sqrt(Q) * math.cos(Fi) + 1
  x2 = -2 * math.sqrt(Q) * math.cos(Fi + (2 * math.pi / 3)) + 1
  x3 = -2 * math.sqrt(Q) * math.cos(Fi - (2 * math.pi / 3)) + 1
elif S < 0:
  #По условию Q всегда больше 0
  Fi = math.acosh(abs(R) / math.sqrt(Q ** 3))/3
  x1 = -2 * sgn(R) * math.sqrt(Q) * math.cosh(Fi) + 1
elif S == 0:
  x1 = -2 * (R ** (1/3)) + 1
  x2 = (R ** (1/3)) + 1
  
print('Приблизительная глубина безопасной кладки:', diapasone(x1, x2, x3, 0, 4))
